using System.Collections.Generic;


namespace ResourceMigrator
{
    /// <summary>
    ///     A static class that defines the configuration for the ResourceMigrator tool.
    /// </summary>
    public static class MigratorConfiguration
    {
        /// <summary>
        ///     Projects with these types will be interpreted as Android projects
        /// </summary>
        public static readonly List<string> AndroidUniqueIds = new List<string> {
            "Droid",
            "Android"
        };

        /// <summary>
        ///     Projects with these types will be interpreted as iOS projects
        /// </summary>
        public static readonly List<string> IosUniqueIds = new List<string> {
            "iOS",
            "MonoTouch"
        };

        /// <summary>
        ///     Projects with these types will be interpreted as PCLs
        /// </summary>
        public static readonly List<string> PclUniqueIds = new List<string> {
            "Portable"
        };

        /// <summary>
        ///     Projects with these strings in their names will be ignored.
        /// </summary>
        public static readonly List<string> UniqueIdBlackList = new List<string> {
            ".Test"
        };


        /// <summary>
        ///     The namespace used to resolve xml references in the parsing of .csproj files
        /// </summary>
        public static readonly string CsprojXmlNamespace = "http://schemas.microsoft.com/developer/msbuild/2003";


        /// <summary>
        ///     The tag to check for determining the project's type
        /// </summary>
        public static readonly string CsprojProjectTypeTag = "Import";


        /// <summary>
        ///     The attribute on the tag in the .csproj file that we check to determine the project type for a given project. This
        ///     attribute's value is compared against the matching lists at the top of the file (blacklist, android, ios...)
        /// </summary>
        public static readonly string ProjectTypeTagAttr = "Project";


        /// <summary>
        ///     The header placed at the top of Android XML resource files to declare the XML document properties and warn the user
        ///     about editing the document.
        /// </summary>
        public static readonly string AndroidXmlHeader = @"<?xml version=""1.0"" encoding=""utf-8""?>

<!-- ..........................................................................
    <auto-generated>
        This code was generated by " + ResourceMigrator.ToolType + @".
        Runtime Version:" + ResourceMigrator.AssemblyInfo + @"

        Changes to this file may cause incorrect behavior and will be lost if
        the code is regenerated.
    </auto-generated>
 ........................................................................... -->

";


        /// <summary>
        ///     The template used to create static classes, such as the Colors.cs class used on the iOS side.
        /// </summary>
        public static readonly string StaticClassTemplate = @"
#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by " + ResourceMigrator.ToolType + @".
//     Runtime Version:" + ResourceMigrator.AssemblyInfo + @"
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace {0}
{{
    public static class {1}
    {{

{2}

    }}
}}
#pragma warning restore 1591
";


        /// <summary>
        ///     The iOS Colors class relies on this code to translate hex values provided in string format over to UIColors which
        ///     are usable in iOS code. Rather than converting the colors into UIColor literals at translation time, we just
        ///     include this method, and have each UIColor entry call it with the string value.
        /// </summary>
        public static readonly string ColorConverterCode = @"

private static UIKit.UIColor FromHexString(string hexValue)
{
    var colorString = hexValue.Replace(""#"", """");
    float red, green, blue;

    switch (colorString.Length)
    {
        case 3: // #RGB
                red = Convert.ToInt32(string.Format(""{0}{0}"", colorString.Substring(0, 1)), 16) / 255f;
                green = Convert.ToInt32(string.Format(""{0}{0}"", colorString.Substring(1, 1)), 16) / 255f;
                blue = Convert.ToInt32(string.Format(""{0}{0}"", colorString.Substring(2, 1)), 16) / 255f;
                return UIKit.UIColor.FromRGB(red, green, blue);
            
        case 6: // #RRGGBB
                red = Convert.ToInt32(colorString.Substring(0, 2), 16) / 255f;
                green = Convert.ToInt32(colorString.Substring(2, 2), 16) / 255f;
                blue = Convert.ToInt32(colorString.Substring(4, 2), 16) / 255f;
                return UIKit.UIColor.FromRGB(red, green, blue);
            
        case 8: // #AARRGGBB
                var alpha = Convert.ToInt32(colorString.Substring(0, 2), 16)/255f;
                red = Convert.ToInt32(colorString.Substring(2, 2), 16)/255f;
                green = Convert.ToInt32(colorString.Substring(4, 2), 16) / 255f;
                blue = Convert.ToInt32(colorString.Substring(6, 2), 16) / 255f;
                return UIKit.UIColor.FromRGBA(red, green, blue, alpha);
            
        default:
            throw new ArgumentOutOfRangeException(string.Format(""Invalid color value {0} is invalid. It should be a hex value of the form #RBG, #RRGGBB, or #AARRGGBB"", hexValue));

    }
}";




    }
}
